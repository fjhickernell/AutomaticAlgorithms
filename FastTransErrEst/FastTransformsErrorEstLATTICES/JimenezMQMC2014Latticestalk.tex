%MCQMC, April 6-11, 2014
%Requires graphics files
%  Lattice64.eps, DualLattice64.eps, PlotFFTCoefUse256.eps, Multicall_conv.eps, Multicall_error.eps

%%%%%%%%%%%%%%%% Springer %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[graybox]{svmult}

\smartqed
\usepackage{mathptmx}       % selects Times Roman as basic font
\usepackage{helvet}         % selects Helvetica as sans-serif font
\usepackage{courier}        % selects Courier as typewriter font
\usepackage{type1cm}        % activate if the above 3 fonts are
                            % not available on your system
\usepackage{graphicx}       % standard LaTeX graphics tool
                            % when including figure files

\usepackage{array,colortbl}
\usepackage{amsmath,amsfonts,amssymb,bm} % no amsthm, Springer defines Theorem, Lemma, etc themselves
%\usepackage[mathx]{mathabx}
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}      {0}{mathx}{"71}

% Note that Springer defines the following already:
%
% \D upright d for differential d
% \I upright i for imaginary unit
% \E upright e for exponential function
% \tens depicts tensors as sans serif upright
% \vec depicts vectors as boldface characters instead of the arrow accent
%
% Additionally we throw in the following common used macro's:
\newcommand{\Z}{\mathbb{Z}} % integers
\newcommand{\C}{\mathbb{C}} % complex numbers
\newcommand{\R}{\mathbb{R}} % reals
\newcommand{\N}{\mathbb{N}} % natural numbers {1, 2, ...}
\newcommand{\Q}{\mathbb{Q}} % rationals
\newcommand{\F}{\mathbb{F}} % field, finite field
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor} % floor
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}    % ceil
\newcommand{\rd}{\,\mathrm{d}} % differential symbol for use in integrals
% vectors as boldsymbols:
\newcommand{\bszero}{\boldsymbol{0}} % vector of zeros
\newcommand{\bsone}{\boldsymbol{1}}  % vector of ones
\newcommand{\bst}{\boldsymbol{t}}    % vector t
\newcommand{\bsu}{\boldsymbol{u}}    % vector u
\newcommand{\bsv}{\boldsymbol{v}}    % vector v
\newcommand{\bsw}{\boldsymbol{w}}    % vector w
\newcommand{\bsx}{\boldsymbol{x}}    % vector x
\newcommand{\bsy}{\boldsymbol{y}}    % vector y
\newcommand{\bsz}{\boldsymbol{z}}    % vector z
\newcommand{\bsDelta}{\boldsymbol{\Delta}}    % vector \Delta
% sets as Euler fraks:
\newcommand{\setu}{\mathfrak{u}}
\newcommand{\setv}{\mathfrak{v}}
% indicator boldface 1:
\DeclareSymbolFont{bbold}{U}{bbold}{m}{n}
\DeclareSymbolFontAlphabet{\mathbbold}{bbold}
\newcommand{\ind}{\mathbbold{1}}


\usepackage{microtype} % good font tricks

\usepackage[colorlinks=true,linkcolor=black,citecolor=black,urlcolor=black]{hyperref}
\urlstyle{same}
\usepackage{bookmark}
\pdfstringdefDisableCommands{\def\and{, }}
\makeatletter % to avoid hyperref warnings:
  \providecommand*{\toclevel@author}{999}
  \providecommand*{\toclevel@title}{0}
\makeatother

%Fred's additions
%
\usepackage{mathtools,array,booktabs,xspace}
\DeclareMathOperator{\ok}{ok}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\spnewtheorem{algo}{Algorithm}{\bf}{\rm}
\newcommand{\bsa}{\boldsymbol{a}}    %%% vector a
\newcommand{\bsh}{\boldsymbol{h}}    %%% vector h
\newcommand{\bsi}{\boldsymbol{i}}    % vector i
\newcommand{\bsj}{\boldsymbol{j}}    %%% vector j
\newcommand{\bsk}{\boldsymbol{k}}    % vector k
\newcommand{\bsl}{\boldsymbol{l}}    % vector l
\newcommand{\bsr}{\boldsymbol{r}}    % vector r
\newcommand{\bsnu}{\boldsymbol{\nu}}    % vector nu
\newcommand{\dif}{{\rm d}}			%%% Differential dx
\newcommand{\me}{\text{e}}			%%% Do not
\newcommand{\cc}{\mathcal{C}}
\newcommand{\cm}{\mathcal{M}}		%%%
\newcommand{\cl}{\mathcal{L}}
\newcommand{\cn}{\mathcal{N}}
\newcommand{\Order}{\mathcal{O}}
\newcommand{\cp}{\mathcal{P}}
\newcommand{\cx}{\mathcal{X}}
\newcommand{\natm}{\N_{0,m}}
\newcommand{\cube}{[0,1)^d}
\newcommand{\hf}{\hat{f}}
\newcommand{\rf}{\mathring{f}}
\newcommand{\tf}{\tilde{f}}
\newcommand{\hg}{\hat{g}}
\newcommand{\hI}{\hat{I}}
\newcommand{\tvk}{\tilde{\bsk}}
\newcommand{\hS}{\widehat{S}}
\newcommand{\tS}{\widetilde{S}}
\newcommand{\wcS}{\widecheck{S}}
\newcommand{\rnu}{\mathring{\nu}}
\newcommand{\tnu}{\widetilde{\nu}}
\newcommand{\hnu}{\widehat{\nu}}
\newcommand{\hbsnu}{\widehat{\bsnu}}   %%%
\newcommand{\homega}{\widehat{\omega}}
\newcommand{\wcomega}{\mathring{\omega}}
\newcommand{\fC}{\mathfrak{C}}
\newcommand{\nodes}{\{\bsz_i\}_{i=0}^{\infty}}
\newcommand{\nodesn}{\{\bsz_i\}_{i=0}^{n-1}}
\newcommand{\norm}[1]{\ensuremath{\left \lVert #1 \right \rVert}}
\newcommand{\abs}[1]{\ensuremath{\left |  #1 \right |}} %%%
\newcommand{\bigabs}[1]{\ensuremath{\bigl \lvert #1 \bigr \rvert}}
\newcommand{\Bigabs}[1]{\ensuremath{\Bigl \lvert #1 \Bigr \rvert}}
\newcommand{\biggabs}[1]{\ensuremath{\biggl \lvert #1 \biggr \rvert}}
\newcommand{\Biggabs}[1]{\ensuremath{\Biggl \lvert #1 \Biggr \rvert}}
\newcommand{\ip}[3][{}]{\ensuremath{\left \langle #2, #3 \right \rangle_{#1}}}

\newcommand{\lattice}{\cl} %you can make your own here
\newcommand{\Lebesgue}{L} %you can make your own here

\allowdisplaybreaks

\title*{Adaptive Multidimensional Integration Based on Rank-1 Lattices}
\author{Llu\'is Antoni Jim\'enez Rugama \and Fred J. Hickernell}
\institute{Llu\'is Antoni \and Fred J. Hickernell \at Department of Applied Mathematics,  Illinois Institute of Technology, 10 W. 32$^{\text{nd}}$ Street, E1-208, Chicago, IL 60616, USA
\email{ljimene1@hawk.iit.edu},\email{hickernell@iit.edu}}
\maketitle

\abstract{Quasi-Monte Carlo methods are used for numerical integration of multivariate functions. However, the error bounds for these methods typically rely on a priori knowledge of some semi-norm of the integrand, not on the sampled function values. In this article, we propose an error bound based on the discrete Fourier coefficients of the integrand. If these Fourier coefficients decay more quickly, the integrand has less fine scale structure, and the accuracy is higher. We focus on rank-1 lattices because they are a commonly used quasi-Monte Carlo design and because their algebraic structure facilitates an error analysis based on a Fourier decomposition of the integrand. This leads to a guaranteed adaptive automatic cubature algorithm with cost $\Order(mb^m)$, where $b^m$ is the number of data points.}

\section{Introduction}

{\bf Problems:  Define $\F_b$, why do we need it?}

Quasi-Monte Carlo (QMC) methods use equally weighted sums of integrand values at carefully chosen nodes,
\[
\frac 1n \sum_{i=0}^{n-1} f(\bsz_i), 
\]
to approximate multidimensional integrals over the unit cube,
\[
\int_{\cube} f(\bsx) \, \dif \bsx.
\]
Integrals over more general domains may often be accommodated by a well-chosen variable transformation. QMC methods are widely used because they do not suffer from a \textit{curse of dimensionality}. For example, if $d>4$, QMC methods with an error of $\Order(n^{-(1-\delta)})$ have a faster convergence rate than the tensor product composite Simpson's rule, which has error of $\Order(n^{-4/d})$.

The convergence rate $\Order(n^{-(1-\delta)})$, although relatively fast, does not give enough information about the absolute error to determine how large $n$ must be to satisfy a given error tolerance, $\varepsilon$. The objective of this research is to develop a guaranteed, QMC algorithm based on rank-1 lattices that determines $n$ adaptively by calculating a data-driven bound on the absolute error. The Koksma-Hlawka inequality is impractical for this purpose because it requires the total variation of the integrand. We focus on constructing a data-driven bound expressed in terms of the integrand's discrete Fourier coefficients. 

Sections \ref{secrank1lat} and \ref{secfourierseries}, describe the group structure of rank-1 lattices and how the complex exponential functions are an appropriate basis for these nodes. For computation purposes, there is also an explanation of how to obatain the discrete Fourier transform $f$ via a Fast Fourier Transform, with in $\Order(n \log(n))$ cost.  The new contributions are described in section \ref{secalgo}. Initially, a mapping from $\N$ to the space of wavenumbers space, $\Z^d$, is defined according to constraints given by the structure of our points. With this mapping, we define a set of integrands for which our new adaptive algorithm is designed.  This set is defined in terms of cone conditions satisfied by the Fourier coefficients. These conditions make it possible to derive an upper bound on the rank-1 lattice rule error in terms of the discrete Fourier coefficients, which can be used to construct an adaptive algorithm.  An upper bound on the computational cost of this algorithm is derived. Finally, there is an example of option pricing using the MATLAB implementation of our algorithm, \texttt{cubLattice\_g}, which will appear in the next release of the Guaranteed Automatic Integration Library \cite{ChoEtal14a}.  A parallel development for Sobol' cubature is given in \cite{HicJim16a}.

\section{Rank-1 Integration Lattices}\label{secrank1lat}
The integrands to be considered are periodic functions over $\cube$. If the function is not initially periodic, it may be periodized as discussed in the Appendix. More general box domains may be considered, also by using variable transformations, see e.g.,  \cite{HicSloWas03a,HicSloWas03e}.

As defined in \cite[Sec. 2.7-2.8]{SloJoe94}, integration lattices $\lattice$ are discrete groups in $\R^d$ containing $\Z^d$. Since our domain of integration is $\cube$, through this article the node set of the lattice that we consider is $\cp:=\lattice/\Z^d$. 

Let $b$ be some integer greater than one, and let $\F_{n}:=\{0, \ldots, n-1\}$ for all $n \in \N$. The aim is to construct a sequence node sets of embedded rank-1 lattices,
\[
\{0\}=\cp_0\subset \cp_1 \dots\subset\cp_m=\{\bsz_i\}_{i=0}^{b^m-1} \subset\dots\subset\cp_\infty=\{\bsz_i\}_{i=0}^{\infty}.
\]
To do this, one chooses $\bsz_1, \bsz_b, \bsz_{b^2},  \ldots$ such that 
\begin{subequations} \label{cpinfvector}
\begin{gather}
i \bsz_{b^{m-1}} \pmod {b^{m}} \ne \bszero \qquad \text{for } i\in \F_{b^m},\ m \in \N \\
b\bsz_1 = \bszero, \qquad b\bsz_{b^m}=\bsz_{b^{m-1}} \quad \text{for } m \in \N ,\label{latpropb}\\
\ip{\bsk}{\bsz_{b^m}} =  0 \ \forall m \in \N_0   \ \implies \ \bsk=\bszero. \label{latpropd}
\end{gather}
Next, for any $i \in \N$ with proper $b$-ary expansion $i=i_0+i_1 b + i_2 b^2 + \cdots$, and $m=\lfloor \log_b(i) \rfloor+1$ define 
\begin{multline}
\bsz_i : = \sum_{\ell=0}^{\infty} i_\ell \bsz_{b^\ell} \bmod 1 = \sum_{\ell=0}^{m-1} i_\ell \bsz_{b^\ell} \bmod 1 = \sum_{\ell=0}^{m-1} i_\ell b^{m-1-\ell}  \bsz_{b^{m-1}} \bmod 1 \\ 
 = j \bsz_{b^{m-1}} \bmod 1, \qquad \text{where } j= \sum_{\ell=0}^{m-1} i_\ell b^{m-1-\ell},
\end{multline}
\end{subequations}
where \eqref{latpropb} was used.  This means that node set $\cp_m$ defined above may be written as the integer multiples of the generating vector $\bsz_{b^{m-1}}$ since 
\[
\cp_m:= \{\bsz_i\}_{i=0}^{b^m-1} = \bigg \{ \bsz_{b^{m-1}} \sum_{\ell=0}^{m-1} i_\ell b^{m-1-\ell} : i_0, \ldots , i_{m-1} \in \F_b \bigg \} = \left\{ j \bsz_{b^{m-1}} : j \in \F_{b^m} \right \}.
\]
The sufficiency of a single generating vector is the reason that this is called the node set of a rank-1 lattice.

Consider $\cube$ with the additive operation $\oplus:\cube \times \cube \to \cube$, $\bsx\oplus\bsy=\bsx+\bsy\pmod 1$. Indeed, $(\cube,\oplus)$ is an Abelian group. Note that $\bszero$ is the additive identity and that the unique additive inverse of $\bsx$ is $\ominus \bsx:=\bsone-\bsx$, where $\bsx \ominus \bst$ means $\bsx \oplus (\ominus \bst)$. Moreover, such a set $\cube$ is also a field over $\R$ where scalar multiplication means when the multiplication modulo $\bsone$.
 
The set $\Z^d$ is used to index Fourier series expressions for the integrands, and $\Z^d$ is also known as the wavenumber space. We define the bilinear operation $\ip{\cdot}{\cdot}: \Z^d \times \cube \to [0,1)$ as the dot product modulo $1$: 
\begin{equation}\label{bilinear}
\ip{\bsk}{\bsx}=\bsk^T\bsx\pmod 1.
\end{equation}
This bilinear operation has the following properties: for all $\bst, \bsx \in \cube$, $\bsk, \bsl \in \Z^d$, and $a \in \R$, it follows that
\begin{subequations}
\begin{gather}
\ip{\bsk}{\bszero} = \ip{\bszero}{\bsx} = 0,\\
\ip{\bsk}{a \bsx \oplus \bst} = a\ip{\bsk}{\bsx} + \ip{\bsk}{\bst} \pmod 1 \label{bilinearlinxprop} \\
\ip{a \bsk + \bsl}{\bsx} = a\ip{\bsk}{\bsx} + \ip{\bsl}{\bsx} \pmod 1, \label{bilinearlinkprop}\\
\ip{\bsk}{\bsx} = 0 \ \forall \bsk \in \Z^d \ \implies \ \bsx=\bszero.\label{bilinearlinzeroprop}
\end{gather}
\end{subequations}

\begin{equation}\label{assumgenip}
\ip{\bsk}{\bsz_{b^{m-1}}}=\ip{b\bsk}{\bsz_{b^m}}
\end{equation}


One example is the extensible rank-1 Lattices whose existence is proved in \cite{HicNie03a}.
%In this case, the generating vector $\bsh$ can be thought in each coordinate as an infinite digit integer. Furthermore, for every $\cp_m$ we can choose a generator of the subgroup. If we want $\bsz_{b^{m-1}}=\bsh\frac{j_m}{b^m}$ to the the generator of $\cp_m$, it only suffices to verify that $\gcd(j_m,b^m)=1$ with $j_m\in\F_{b^m}$. This sequence $j_0,j_1,\dots$ defines $\cp_\infty$. In addition, to satisfy equation \eqref{latpropb},  $j_m$'s: $ b^{m-1} \mid j_m-j_{m-1}\Rightarrow j_m=j_{m-1}+b^{m-1},\;\forall m\in\N$. A part from that, \eqref{latpropc} implies that the order of the elements in $\cp_\infty$ given the generators must follow the Sobol' order.

The bilinear operation previously mentioned in \eqref{bilinear} let us also define the \emph{dual} Lattice corresponding to $\cp_m$ as
\begin{align}
\nonumber
\cp^{\perp}_m &= \{\bsk \in \Z^d : \ip{\bsk}{\bsz_i} = 0, \ i=0, \ldots, b^m-1\} \\
&= \{\bsk \in \Z^d : \ip{\bsk}{\bsz_{b^{l}}} = 0, \ l=0, \ldots, m-1\}.\label{dualdef}
\end{align}
By this definition $\cp^{\perp}_{0}=\Z^d$ and the properties \eqref{bilinear} together with \eqref{cpinfvector}, imply also that $\cp^{\perp}_m$ are subgroups with
\begin{equation}\label{dualemb}
\Z^d=\cp^{\perp}_{0}\supseteq\dots\supseteq\cp^{\perp}_{m}\supseteq\dots\supseteq\cp^{\perp}_{\infty}=\{0\}.
\end{equation}

One may see that for any rank-1 Lattice there exists infinitely many dual Lattice points. Figure \eqref{Latticefig} shows an example of a rank-1 Lattice and some of its dual Lattice points in dimension 3. For $\bsh=(1,3,7)$, $b=2$ and $m=6$:
\begin{figure}[h!]
\centering
\begin{tabular}{>{\centering}p{5cm}>{\centering}p{5cm}}
\includegraphics[width=5cm]{Images/Lattice64.eps} &
\includegraphics[width=5cm]{Images/DualLattice64.eps}\tabularnewline
a) & b)
\end{tabular}
\caption{a) Plot of $\cp_6$, b) Some of the corresponding dual Lattice points inside $[-10,10]^3$.}\label{Latticefig}
\end{figure}

\section{Fourier Series}\label{secfourierseries}

The integrands are assumed to be periodic and belong to some subset of $\Lebesgue_2(\cube)$, the space of square integrable functions. For non periodic integrands we suggest some transforms in Appendix A. The $\Lebesgue_2$ inner product is defined as
\[
\ip[2]{f}{g} = \int_{\cube} f(\bsx) \overline{g(\bsx)} \, \dif \bsx.
\]
Let $\{\varphi(\cdot,\bsk) \in \Lebesgue_2(\cube) : \bsk \in \Z^d\}$ be the complete orthonormal Fourier function \emph{basis} for $\Lebesgue_2(\cube)$, i.e.,
\[
\varphi(\bsx,\bsk)  = \E^{2 \pi \sqrt{-1} \ip{\bsk}{\bsx}}, \qquad \bsk \in \Z^d, \ \bsx \in \cube.
\]
Then any function in $\Lebesgue_2$ may be written in series form as
\begin{equation} \label{Fourierdef}
f(\bsx) = \sum_{\bsk \in \Z^d} \hf(\bsk) \varphi(\bsx,\bsk), \quad \text{where } \hf(\bsk) = \ip[2]{f}{\varphi(\cdot,\bsk)},
\end{equation}
and the inner product of two functions in $\Lebesgue_2$ is the $\ell_2$ inner product of their series coefficients:
\[
\ip[2]{f}{g} = \sum_{\bsk \in \Z^d} \hf(\bsk)\overline{\hg(\bsk)} =: \ip[2]{\bigl(\hf(\bsk)\bigr)_{\bsk \in \Z^d}}{\bigl ( \hg(\bsk)\bigr )_{\bsk \in \Z^d}}.
\]

Note that for any $\bsz\in\cp_m$ and $\bsk\in\cp_m^\perp$, we have that $\varphi(\bsz,\bsk)=1$. This special group structure of the Lattice $\cp_m$ leads to a useful formula for the average of any Fourier basis function over $\cp_m$. For all $\bsk \in \Z^d$ and $\bsx \in \cp_m$, it follows that
\begin{align*}
\nonumber
0 & = \frac{1}{b^m} \sum_{i=0}^{b^m-1} [\varphi(\bsz_i,\bsk) - \varphi(\bsz_i \oplus \bsx,\bsk)]
= \frac{1}{b^m} \sum_{i=0}^{b^m-1} [\E^{2 \pi \sqrt{-1} \ip{\bsk}{\bsz_i}} - \E^{2 \pi \sqrt{-1} \ip{\bsk}{\bsz_i \oplus \bsx}}]\\
\nonumber
& = \frac{1}{b^m} \sum_{i=0}^{b^m-1} [\E^{2 \pi \sqrt{-1} \ip{\bsk}{\bsz_i}} - \E^{2 \pi \sqrt{-1} \{\ip{\bsk}{\bsz_i}+\ip{\bsk}{\bsx}\}}] \quad \text{by } \eqref{bilinearlinxprop}\\
\label{sumeq}
& = [1 - \E^{2 \pi \sqrt{-1} \ip{\bsk}{\bsx})}] \frac{1}{b^m} \sum_{i=0}^{b^m-1} \varphi(\bsz_i,\bsk)
\end{align*}
By this equality one has that the average of a Fourier basis function sampled over the points in a Lattice is either one or zero, depending on whether the wavenumber $\bsk$ is in the dual Lattice or not:
\begin{equation}\label{avrFourier}
\frac{1}{b^m} \sum_{i=0}^{b^m-1} \varphi(\bsz_i,\bsk) = \ind_{\cp_m^{\perp}}(\bsk) = \begin{cases} 1 , & \bsk \in \cp_m^{\perp}\\
 0,  & \bsk \in \Z^d \setminus \cp_m^{\perp}.
 \end{cases}
\end{equation}

The above result is used below to describe the absolute error of Shifted rank-1 Lattice rules in terms of the dual Lattice. With this method we approximate multivariate integrals by taking the average of the integrand sampled over a shifted Lattice, namely,

\begin{equation} \label{cubaturedef}
\hI_m(f) := \frac{1}{b^m} \sum_{i=0}^{b^m-1} f(\bsz_i \oplus\bsDelta_i).
\end{equation}

Using the series decomposition defined in \eqref{Fourierdef} and equation \eqref{avrFourier}, it follows that the error of the Lattice rule is the sum of the Fourier coefficients of the integrand for those wavenumbers in the dual Lattice:

\begin{align}
\nonumber
\biggabs{ \int_{\cube} f(\bsx) \, \D \bsx - \hI_m(f)} 
& = \Biggabs {\hf(\bszero) - \sum_{\bsk \in \Z^d} \hf(\bsk) \hI_m\left(\varphi(\cdot,\bsk)\right)} \\
\nonumber
& = \Biggabs {\hf(\bszero) - \sum_{\bsk \in \Z^d} \hf(\bsk) \ind_{\cp_m^{\perp}}(\bsk) \varphi(\bsDelta,\bsk)} \\ 
& = \Biggabs {\sum_{\bsk \in \cp_m^{\perp}\setminus \{\bszero\} } \hf(\bsk)  \varphi(\bsDelta,\bsk)}. \label{err1}
\end{align}

Adaptive Algorithm \ref{adapalgo} that we construct in section \ref{algorithmsection} is built using this expression and adapting it in terms of the discrete Fourier coefficients. This is because one does not have to assume the knowledge of the Fourier coefficients a priori. For this article, they are estimated as:

\begin{align}
\nonumber
\tf_m(\bsk)
&:= \hI_m\left( \varphi(\cdot,\bsk) f(\cdot) \right) \\
\nonumber
&= \frac{1}{b^m} \sum_{i=0}^{b^m-1} \E^{-2 \pi \sqrt{-1} \ip{\bsk}{\bsz_i\oplus\bsDelta}} f(\bsz_i\oplus\bsDelta) \\
\nonumber
&= \frac{1}{b^m}  \sum_{i=0}^{b^m-1} \left[\E^{-2 \pi \sqrt{-1} \ip{\bsk}{\bsz_i\oplus\bsDelta}}\sum_{\bsl \in \Z^d} \hf(\bsl) \E^{2 \pi \sqrt{-1} \ip{\bsl}{\bsz_i\oplus\bsDelta}} \right] \\
\nonumber
& = \sum_{\bsl \in \Z^d} \hf(\bsl)  \frac{1}{b^m}  \sum_{i=0}^{b^m-1}  \E^{2 \pi \sqrt{-1} \ip{\bsl - \bsk}{\bsz_i\oplus\bsDelta}} \\
\nonumber
& = \sum_{\bsl \in \Z^d} \hf(\bsl) \E^{2 \pi \sqrt{-1} \ip{\bsl - \bsk}{\bsDelta}}  \frac{1}{b^m}  \sum_{i=0}^{b^m-1}   \varphi(\bsz_i,\bsl - \bsk) \\
\displaybreak[0] \nonumber
& = \sum_{\bsl \in \Z^d} \hf(\bsl) \E^{2 \pi \sqrt{-1} \ip{\bsl - \bsk}{\bsDelta}} \ind_{\cp_m^{\perp}}(\bsl - \bsk) \\
\nonumber
& = \sum_{\bsl \in \cp^{\perp}_m} \hf(\bsk+\bsl) \varphi(\bsDelta,\bsl) \\
&= \hf(\bsk) + \sum_{\bsl \in \cp^{\perp}_m\setminus \{\bszero\}} \hf(\bsk+\bsl) \varphi(\bsDelta,\bsl), \qquad \forall \bsk \in \Z^d. \label{tfassum}
\end{align}
It is seen here that the discrete transform $\tf_m(\bsk)$ is equal to the integral transform $\hf(\bsk)$, defined in \eqref{Fourierdef}, plus the \emph{aliasing} terms corresponding to $\hf(\bsk+\bsl)$ scaled by the shift, where $\bsl \in \cp_{m}^{\perp}\setminus \left\{\bszero\right\}$.

\subsection{Fast Fourier Transform Adapted to Rank-1 Lattices}\label{FFT}

The next goal is to define the map $\hbsnu : \Z^d \to \F_b^{\infty}$, and $\tnu_m : \Z^d \to \F_{b^m}$ that facilitates the calculation of the discrete Fourier transform introduced below.

\begin{definition} \label{numapdef} For every $\bsk \in \Z^d$, let
\begin{subequations} \label{numapdefeq}
\begin{gather}
\hbsnu(\bsk)=(\hnu_0(\bsk), \hnu_1(\bsk), \hnu_2(\bsk), \ldots ), \\
\hnu_0(\bsk) = b\ip{\bsk}{\bsz_{1}}, \qquad \hnu_m(\bsk)=b\ip{\bsk}{\bsz_{b^m}}-\ip{\bsk}{\bsz_{b^{m-1}}}, \quad m \in \N, \\
\tnu_m(\bsk) = \sum_{\ell=0}^{m-1} \hnu_{\ell}(\bsk) b^{\ell}, \quad m \in \N.
\end{gather}
\end{subequations}
\end{definition}

These maps have certain desirable properties. Mainly, they identify any wavenumber with a particular sequence in $\F_b$ that will be helpful to track the discrete Fourier coefficients computed in $\Order(n\log(n))$.

\begin{lemma} \label{numaplem} The following is true for the maps in Definition \ref{numapdef}:
\begin{enumerate}
\item $\hbsnu(\bszero)=\bszero$ and $\tnu_m(\bszero) = 0$ for all $m \in \N$.
\item $\hnu_m(\bsk)\in \{0,\dots,b-1\}$ and $\tnu_m(\bsk)\in \{0,\dots,b^m-1\}$ for all $m\in\N_0$.
\item for all $m\in \N_0$ and all $\bsnu \in \F_b^{m}$ there exist a unique $\bsk \in \Z^d$ with $\hbsnu(\bsk)=(\nu_0, \ldots, \nu_{m-1}, \ldots)$.
\item for any $m \in \N_0$, $i \in \{0, \ldots, b^m-1\}$,  $\tnu_m(\bsk)=\nu=(\nu_0, \nu_1, \ldots)$, and $\bsi=(i_0, i_1, \ldots)$, it follows that
\begin{align} \label{nuwisum}
\begin{split}
\ip{\bsk}{\bsz_i} &= \sum_{\ell=0}^{m-1} i_\ell [\nu \pmod  {b^{(l+1)}}]  b^{-(l+1)} \pmod 1
\end{split}
\end{align}

\end{enumerate}
\end{lemma}

\begin{proof}
\begin{enumerate}
\item Directly from definition.
\item Using \eqref{latpropc} and by construction, $\hnu_0(\bsk)\in\{0,\dots,b-1\}$ and $\hnu_m(\bsk)\in (-1,b)$. Using the assumption \eqref{latpropb}, $\hnu_m(\bsk)\pmod 1=\bsk^Tb\bsz_{b^m}\pmod 1-\bsk^T\bsz_{b^{m-1}}\pmod 1=0$. Then, $\hnu_m(\bsk)\in (-1,b)\cap\Z=\{0,\dots,b-1\},\;\forall m\in\N_0$.

\item For injection, we are proving that $\hbsnu(\bsk)=\hbsnu(\bsl) \Rightarrow \bsk = \bsl$. If $\hbsnu(\bsk)=\hbsnu(\bsl)$, $\hnu_m(\bsk)=\hnu_m(\bsl),\;\forall m\in\N_0$. In particular for $m=0$, this implies $\ip{\bsk}{\bsz_1}-\ip{\bsl}{\bsz_1}=0$. Recursively, one obtains that $\ip{\bsk}{\bsz_{b^m}}-\ip{\bsl}{\bsz_{b^m}}=0$. Therefore, $\ip{\bsk}{\bsz_{b^{m}}}-\ip{\bsl}{\bsz_{b^{m}}}=\ip{\bsk-\bsl}{\bsz_{b^{m}}}=0$ for all $m\in\N_0$ and by \eqref{latpropd}, $\bsk=\bsl$.

For surjection, by \eqref{bilinearlinzeroprop} there exists $\bsk$ such that $\hnu_0(\bsk)=\nu\neq 0$. Furthermore due to the property \eqref{bilinearlinkprop}, $\hnu_0(a\bsk)=a\nu \pmod b$ and recalling the Lagrange's Theorem, any element $\nu$ different than the identity generates the group $\F_b$. Therefore, for $a=1,\dots,b-1$ we can obtain all elements in $\F_b$. Now, for any $\ell\leq m\in\N$ and using \eqref{assumgenip},
\begin{align*}
\hnu_\ell(\bsk+b^m\bsa)&=
\begin{cases}
b\ip{\bsk}{\bsz_{b^\ell}}-\ip{\bsk}{\bsz_{b^{\ell-1}}}+b\ip{\bsa}{\bsz_{1}} \pmod b  &\mbox{if } \ell=m, \\
b\ip{\bsk}{\bsz_{b^\ell}}-\ip{\bsk}{\bsz_{b^{\ell-1}}} &\mbox{if } \ell<m   \end{cases}\\
&=
\begin{cases}
\hnu_\ell(\bsk)+\hnu_0(\bsa) \pmod b  &\mbox{if } \ell=m, \\
\hnu_\ell(\bsk) &\mbox{if } \ell<m   \end{cases}\\
\end{align*}%Remark that for the first equality we use the fact that $\ip{\bsk}{\bsz_{b^{m-1}}}=\ip{\bsk}{\bsz_{b^{m-1}}}\pmod b$. 
Therefore, for all $m\in \N_0$ and all $(\nu_0,\dots,\nu_m) \in \F_b^{m+1}$ one can build recursively $\bsk \in \Z^d$ such that  $\hnu_\ell(\bsk)=\nu_\ell$, $\ell=0,\dots,m$.

\item Directly by applying \eqref{bilinearlinxprop} and Definition \ref{numapdef}:
\begin{align*}
\ip{\bsk}{\bsz_i} &= \ip{\bsk}{\sum_{\ell=0}^{m-1} i_\ell \bsz_{b^{\ell}}} = \sum_{\ell=0}^{m-1} i_\ell \ip{\bsk}{\bsz_{b^{\ell}}} \pmod 1 \\
& = \sum_{\ell=0}^{m-1} i_\ell \sum_{j=0}^{\ell} \nu_jb^{j-(\ell+1)} \pmod 1\\
&=\sum_{\ell=0}^{m-1} i_\ell [\nu \pmod  {b^{(\ell+1)}}]  b^{-(\ell+1)} \pmod 1.
\end{align*}
\end{enumerate}
\hfill\qed
\end{proof}
%\subsection{Computation of the Discrete Transform}
We proceed now with the description of how the adapted Fast Fourier Transform is built. Letting the input data points $y_i=f(\bsz_i\oplus \bsDelta)$,
\[
Y_{m,0}(i_0,\ldots, i_{m-1}) = y_i, \qquad i=i_0 + i_1 b + \cdots + i_{m-1} b^{m-1},
\]
the discrete transform defined in \eqref{tfassum} may also be expressed as
\begin{align}
\nonumber
\tf_m(\bsk):=\varphi(\bsDelta,\bsk)  Y_{m,m}(\nu_0, \ldots, \nu_{m-1}).
\end{align}
where $ Y_{m,m}(\nu_0, \ldots, \nu_{m-1})$ is the output. Invoking Lemma \ref{numaplem}, for any $\bsk \in \Z^d$ with $\tnu_m(\bsk)=\nu = \nu_0 + \nu_1 b  + \cdots + \nu_{m-1} b^{m-1}$ one may write
\begin{align}
\nonumber
\MoveEqLeft{Y_{m,m}(\nu_0, \ldots, \nu_{m-1})} : = \frac{1}{b^m} \sum_{i=0}^{b^m-1} \E^{-2 \pi \sqrt{-1} \ip{\bsk}{\bsz_i}} y_i \\
\nonumber
& = \frac{1}{b^m} \sum_{i_{m-1}=0}^{b-1} \cdots \sum_{i_0=0}^{b-1} \E^{-2 \pi \sqrt{-1}\sum_{l=0}^{m-1} i_l [\nu \pmod  {b^{(l+1)}}]  b^{-(l+1)}} Y_{m,0}(i_0,\ldots, i_{m-1}) \\
\nonumber
& = \frac{1}{b} \sum_{i_{m-1}=0}^{b-1}\E^{-2 \pi \sqrt{-1}  i_{m-1}[\nu \pmod  {b^{m}}]  b^{-m}}  \times\cdots\times \\
&\qquad \qquad \frac{1}{b} \sum_{i_0=0}^{b-1} \E^{-2 \pi \sqrt{-1} i_0 [\nu \pmod  {b}]  b^{-1}} Y_{m,0}(i_0,\ldots, i_{m-1})
\nonumber
\end{align}
and this sum can be computed recursively in $\Order(mb^m)$:
\begin{multline*}
Y_{m,l+1}(\nu_0, \ldots, \nu_{l},i_{l+1}, \ldots, i_m) \\
= \frac{1}{b} \sum_{i_l=0}^{b-1} \E^{-2 \pi \sqrt{-1}  i_{l}[\nu \pmod  {b^{(l+1)}}]  b^{-(l+1)}} Y_{m,l}(\nu_0, \ldots, \nu_{l-1},i_{l}, \ldots, i_m).
\end{multline*}
for $\ell=0,\dots,m-1$.

\section{Error Estimation and an Adaptive Algorithm}\label{secalgo}

\subsection{Wavenumber Map}

As seen in equation \eqref{err1}, the absolute error is directly a sum of the Fourier coefficients in the dual Lattice scaled by the shift. Note that increasing the number of points in our Lattice, i.e. $m$, the number of summands decrease and in the limit, this sum should vanish for integrands in $\Lebesgue^2$. However, one can not capture how fast is this error decreasing with respect to $m$ unless we order these wavenumbers. For this purpose, we define another mapping $\tvk: \N_0 \to \Z^d$.

\begin{definition} \label{wavenummapdef} Given a sequence of points in embedded Lattices, $\cp_{\infty} = \{\bsz_i\}_{i=0}^{\infty}$ define $\tvk: \N_0 \to \Z^d$ recursively as follows:
\begin{description}
\item[\textbf{Step 1.}] $\tvk(0)=\bszero$.

\item[\textbf{Step 2.}] For $m=0, 1, \ldots$ \\
\hspace*{1.3cm} For $\kappa = 1, \ldots, b^{m} -1 $ \\
\hspace*{1.6cm} Choose the values of $\tvk(\kappa+b^{m}), \ldots, \tvk(\kappa+(b-1)b^{m})$ from the sets
\[
\{\bsk : \bsk - \tvk(\kappa) \in \cp_{m}^{\perp}, \ip{\bsk - \tvk(\kappa)}{\bsz_{b^m}}=a/b \}, \quad a=1, \ldots, b-1,
\]
\hspace*{1.6cm} but not necessarily in that order.
\end{description}
\end{definition}

This mapping is not completely defined and one has the flexibility to choose part of it. For example, defining a norm such as in \cite[Chap. 4]{SloJoe94} one can assign bigger values of $\kappa$ to higher frequencies $\bsk$. In the end, our goal is to define this mapping such that $\hf(\tvk(\kappa))\rightarrow 0$ for increasing $\kappa$.

To explain the hidden constraint in this mapping, we need to define the dual cosets. Given the dual Lattice $\cp_{m}^{\perp}$, for $m\in\N_0$ one can find another $b^m-1$ cosets redefining \eqref{dualdef},
\begin{align}
\cp_{m,c_m}^\perp:=\{\bsk \in \Z^d : \ip{\bsk}{\bsz_{b^{\ell}}} = c_m/b^m, \ \ell=0, \ldots, m-1\}, \; c_m=0, \ldots, b^m-1.\label{dualdefcoset}
\end{align}
Here, $\cp_{m}^{\perp}=\cp_{m,0}^\perp$ and the embedded structure described earlier in \eqref{dualemb} is inherited for any coset:
\begin{equation}\label{dualemb}
\Z^d=\cp^{\perp}_{0,0}\supseteq\dots\supseteq\cp^{\perp}_{m,c_m}\supseteq\dots\supseteq\cp^{\perp}_{\infty}=\{0\}.
\end{equation}
Therefore, in order to preserve this structure, Definition \ref{wavenummapdef} obliges that
\begin{equation}
\cp^{\perp}_{m,c_m}=\bigoplus_{a=0}^{b-1}\cp^{\perp}_{m+1,c_m+ab^m}, \qquad m\in\N_0.
\end{equation}

Applying this mapping to \eqref{tfassum} and using the notation $\hf_{\kappa} :=\hf(\tvk(\kappa))$, $\tf_{m,\kappa} := \tf_m(\tvk(\kappa))$, we have
\begin{equation}
\tf_{m,\kappa} = \hf_{\kappa} + \sum_{\lambda=1}^{\infty} \hf_{\kappa+\lambda b^{m}} \E^{2 \pi \sqrt{-1} \ip{\tvk(\kappa+\lambda b^{m}) - \tvk(\kappa)}{\bsDelta}}.
\label{tfassumc}
\end{equation}
and thus, the error in \eqref{err1} can be bounded as
\begin{equation}
\biggabs{ \int_{\cube} f(\bsx) \, \D \bsx - \hI_m(f)} 
= \Biggabs {\sum_{\lambda=1}^{\infty} \hf_{\lambda b^m} \E^{2 \pi \sqrt{-1} \ip{\tvk(\lambda b^m)}{\bsDelta}}}
\le \sum_{\lambda=1}^{\infty} \left \lvert \hf_{\lambda b^m}\right \rvert. \label{err2}
\end{equation}

In the section below, we disclose how to use the discrete transform coefficients $\tf_{m,\kappa}$ instead of the true Fourier coefficients $\hf_{\kappa}$, to construct a new error bound based on \eqref{tfassumc} and \eqref{err2}.

\subsection{Cone Condition: Decay of the Fourier Coefficients}\label{sumscoeff}
Given a function $f\in\Lebesgue^2(\cube)$, consider the following sums of its series coefficients defined for $\ell,m \in \N_0$, $\ell \le m$:
\begin{gather*}
S_m(f) =  \sum_{\kappa=\left \lfloor b^{m-1} \right \rfloor}^{b^{m}-1} \bigabs{\hf_{\kappa}}, \qquad 
\hS_{\ell,m}(f)  = \sum_{\kappa=\left \lfloor b^{\ell-1} \right \rfloor}^{b^{\ell}-1} \sum_{\lambda=1}^{\infty} \bigabs{ \hf_{\kappa+\lambda b^{m}}}, \\
\wcS_m(f)=\hS_{0,m}(f) + \cdots + \hS_{m,m}(f)=
\sum_{\kappa=b^{m}}^{\infty} \bigabs{\hf_{\kappa}}, \qquad
\tS_{\ell,m}(f) = \sum_{\kappa=\left \lfloor b^{\ell-1}\right \rfloor}^{b^{\ell}-1} \bigabs{\tf_{m,\kappa}}.
\end{gather*}
From these sums, remark that $\tS_{\ell,m}(f)$ is the only one involving the discrete transform coefficients. Indeed, our adaptive algorithm will be based on this sum bounding the other three, $S_m(f),\hS_{\ell,m}(f),\wcS_m(f)$ that can not be easily observed. Furthermore, these fast Fourier coefficients converge to the true Fourier coefficients for $m$ big enough.

Define $\cc$ the set of functions characterized by critical assumptions about how certain sums provide upper bounds on others.  Let $\ell_* \in \N$ be some fixed integer and $\homega$ and $\wcomega$ be some bounded non-negative valued functions such that,
\begin{multline} \label{conecond}
\cc:=\{f \in \Lebesgue_2(\cube) : \hS_{\ell,m}(f) \le \homega(m-\ell) \wcS_m(f),\ \ \ell \le m, \\
\wcS_m(f) \le \wcomega(m-\ell) S_{\ell}(f),\ \  \ell_* \le \ell \le m\}.
\end{multline}
We also require the existence of $r$ such that $\homega(r) \wcomega(r)<1$, for instance if $\lim_{r\rightarrow\infty}\wcomega(r)=0$. Note that although this set is a cone, i.e. $f \in \cc \implies af \in \cc\;\forall a\in\R$, it is not convex. A wider discussion on the advantages and disadvantages of considering cones of functions can be found in \cite{Clancy201421}.

Functions in $\cc$ have a smooth decay on their Fourier coefficients since by definition, sums $S_m(f)$ can not bounce with respect to $\hS_{\ell,m}(f)$ or $\wcS_m(f)$. Thus, under these assumptions the size of these sums can be a good indicator of the absolute error since once the sums are small, they can not bounce back again.

The first inequality parameterizes how fast the coefficients must decay. There, an infinite sum of larger indexed Fourier coefficients bound an infinite partial sum of itself. In Figure \ref{Walshcoeffig} for example, it is shown how $\wcS_{12}(f)$ is bounding $\hS_{0,12}$. Remark that the last sum is directly the bound obtained in \eqref{err2}.

The second inequality also controls the previous sums' decay by a finite sum on smaller indexed Fourier coefficients. Again, in Figure \ref{Walshcoeffig} we can see how $S_8(f)$ is proportionally bounding $\wcS_{12}(f)$. In addition, below we explain how this inequality is also crucial for introducing $\tS_{\ell,m}(f)$ in the error bound.

Finally, for small $\ell$ the sum $S_\ell(f)$ includes only a few summands. Therefore, it could accidentally happen that $S_\ell(f)$ is too small compared to $\wcS_m(f)$. To avoid it, the cone is defined for $\ell$ greater than a minimum $\ell_*$.
\begin{figure}
\centering
\includegraphics[width=9cm]{Images/PlotFFTCoefUse256.eps}
\caption{The magnitudes of true Walsh coefficients for some integrand. \label{Walshcoeffig}}
\end{figure}

Because we do not assume the knowledge of the true coefficients, for functions in $\cc$ we introduce $\tS_{\ell,m}(f)$ in the error bound using \eqref{tfassumc},
\begin{align}
\nonumber
S_\ell(f) &= \sum_{\kappa=b^{\ell-1}}^{b^{\ell}-1} \bigl \lvert \hf_{\kappa}\bigr\rvert= \sum_{\kappa=b^{\ell-1}}^{b^{\ell}-1} \abs{\tf_{m,\kappa} - \sum_{\lambda=1}^{\infty} \hf_{\kappa+\lambda b^{m}} \E^{2 \pi \sqrt{-1} \ip{\tvk(\kappa+\lambda b^{m}) \ominus \tvk(\kappa)}{\bsDelta}}}\\
\nonumber
&\le \sum_{\kappa=b^{\ell-1}}^{b^{\ell}-1} \bigl \lvert \tf_{m,\kappa} \bigr\rvert + \sum_{\kappa=b^{\ell-1}}^{b^{\ell}-1} \sum_{\lambda=1}^{\infty} \bigl \lvert \hf_{\kappa+\lambda b^{m}}\bigr\rvert = \tS_{\ell,m}(f) + \hS_{\ell,m}(f) \\
\label{boundSumbsApproxa}
&\le \tS_{\ell,m}(f) + \homega(m-\ell) \wcomega(m-\ell) S_\ell\
\end{align}
and provided that $\homega(m-\ell) \wcomega(m-\ell)<1$,
\begin{equation}\label{boundSumsApproxb}
S_\ell(f) \le \frac{\tS_{\ell,m}(f)}{1 - \homega(m-\ell) \wcomega(m-\ell)}.
\end{equation}
The above inequality leads to, by \eqref{err2} and the cone conditions,
\begin{align}
\nonumber
\biggabs{\int_{\cube} f(\bsx) \, \D \bsx - \hI_m(f) }
&\le \sum_{\lambda=1}^{\infty} \bigabs{\hf_{\lambda b^{m}}} 
= \hS_{0,m}(f)\le \homega(m) \wcS_m(f)\\
\nonumber
&  \le \homega(m) \wcomega(m-\ell) S_\ell(f)\\
& \le  \frac{\homega(m) \wcomega(m-\ell)}{1 - \homega(m-\ell) \wcomega(m-\ell)}\tS_{\ell,m}(f)
\label{SSbd2}
\end{align}
With this result, Algorithm \ref{adapalgo} can be defined in terms of this conservative bound. This bound is taking into account the discrete Fourier coefficients of $f$, making it adaptive. 

\subsection{Adaptive Algorithm Based on $\cc$}\label{algorithmsection}

Inequality \eqref{SSbd2} suggests the following algorithm. First, choose $\ell_*$ and fix $r:=m-l \in \N$ such that $\homega(r)\wcomega(r)<1$ for $\ell\geq\ell_*$. Then, define
\[
\fC(m):= \frac{\homega(m) \wcomega(r)}{1 - \homega(r) \wcomega(r)}.
\]

The choice of the parameter $r$ is important. Larger $r$ means a bigger $\fC(m)$ although makes the error more dependent on smaller indexed Fourier coefficients.

\begin{algo}[Adaptive Rank-1 Lattices Integration, \texttt{cubLattice\_g}] \label{adapalgo} Fix $r$, $\ell_*$ as described above and $\homega$ and $\wcomega$ describing $\cc$ in \eqref{conecond}. Given a tolerance, $\varepsilon$, do the following:

\begin{description}
\item[\textbf{Step 1.}] According to section \ref{FFT}, compute $\tS_{m-r,m}(f)$.
\item[\textbf{Step 2.}] Verify if $\fC(m)  \tS_{m-r,m}(f) \le \varepsilon$: If true, return $\hI_m(f)$ defined in \eqref{cubaturedef}. If not, increment $m$ by one, and go to Step 1.
\end{description}
\end{algo}

The algorithm described has been coded in MATLAB as \texttt{cubLattice\_g} in base 2, and is intended to appear in the next release for the Guaranteed Automatic Integration Library, \cite{ChoEtal14a}.
The computational cost is $\Order(m b^m)$ considering the operations of the discrete Fourier transform in addition to the function data points evaluation.

\begin{theorem} \label{adapalgothm} For $m = \min \{m' \ge \ell_*+r : \fC(m')  \tS_{m'-r,m'}(f) \le \varepsilon \}$, Algorithm \ref{adapalgo} is successful whenever $f\in\cc$,
\[
\biggabs{\int_{\cube} f(\bsx) \D \bsx - \hI_m(f)} \le \varepsilon.
\]
Thus, the number of function data points needed are $b^m$. Defining $m^* = \min \{m' \ge \ell_*+r : \fC(m') [1+ \homega(r) \wcomega(r)] S_{m'-r}(f) \le \varepsilon \}$, we also have $b^m\leq b^{m^*}$. This means that the computational cost can be bounded,
\[
\mathrm{cost}\left(\widehat{I}_m,f,\varepsilon\right)\leq \$(f)b^{m^*}+cm^*b^{m^*}
\]
where $\$(f)$ is the cost of evaluating $f(x)$ at one data point.
\end{theorem}

\begin{proof}
By construction, the algorithm must be successful. Recall that the inequality used for building the algorithm is \eqref{SSbd2}.

In order to find the upper bound on the complexity one can obtain, analogously to the result in \eqref{boundSumbsApproxa},
\begin{align}
\nonumber
\tS_{\ell,m}(f) &= \sum_{\kappa=b^{\ell-1}}^{b^{\ell}-1} \bigabs{ \tf_{m,\kappa}} = \sum_{\kappa=b^{\ell-1}}^{b^{\ell}-1} \biggabs{\hf_{\kappa} + \sum_{\lambda=1}^{\infty} \hf_{\kappa+\lambda b^{m}} \E^{2 \pi \sqrt{-1} \ip{\tvk(\kappa+\lambda b^{m}) \ominus \tvk(\kappa)}{\bsDelta}}}\\
\nonumber
&\le \sum_{\kappa=b^{\ell-1}}^{b^{\ell}-1} \bigabs{\hf_{\kappa}} + \sum_{\kappa=b^{\ell-1}}^{b^{\ell}-1} \sum_{\lambda=1}^{\infty} \bigabs{\hf_{\kappa+\lambda b^{m}}} 
= S_{\ell}(f) + \hS_{\ell,m}(f) \\
\nonumber
&\le [1  + \homega(m-\ell) \wcomega(m-\ell)] S_\ell(f). \label{SSbd3}
\end{align}
Hence, the bound in \eqref{SSbd2} leads to a new more conservative bound $\fC(m) [1  + \homega(r) \wcomega(r)] S_{m-r}(f)$ implying $
m \le {\min \{m' \ge \ell_*+r : \fC(m') [1+ \homega(r) \wcomega(r)] S_{m'-r}(f) \le \varepsilon \}}$.

In section \ref{FFT}, the computation of $\tS_{m-r,m}(f)$ is described in terms of $\Order(mb^m)$ operations. Thus, the total cost of Algorithm \ref{adapalgo} is,
\[
\mathrm{cost}\left(\widehat{I}_m,f,\varepsilon\right)\leq \$(f)b^{m^*}+cm^*b^{m^*}
\]
\hfill \qed
\end{proof}

\section{Numerical Example} \label{secnumexpsec}

With $\texttt{cubLattice\_g}$ implemented, we tested the pricing of a basket European option. Assumptions were: 5 decorrelated stocks with $S_0=100$, $K=100$, $r=1\%$, $\sigma=5\%$ and $T=1$. The algorithm parametrization according to the cone chosen by default was: $\ell_*=6$, $r=4$ and $\fC(m)=3 \times 2^{-m}$.

Results are shown in Figure \ref{BasketOption}. On the left, one can compare the predicted error bound in continuous line, with the input error tolerance represented in discontinuous. By definition, the tolerance should be above the prediction, except for budget restrictions. However, the continuous line flattens because we do not allow to use more than $2^{17}$ points. This number comes from the Korobov construction using $17797$ as suggested in \cite{HicEtal00}. Another important remark is that the predicted error might increase with the number of points. Nonetheless, this is only due to the varying random shift taken each time.

On the right plot one can appreciate the price obtained together with the tolerance bounds. This bounds on the error are only guaranteed if the function lies in the cone parametrized. Although we did not know the coefficients true decay, the error intervals in the graph seem to be consistent, i.e. the intersection of all the tolerance intervals is not empty.
\begin{figure}[h!]
\centering
\begin{tabular}{>{\centering}p{5cm}>{\centering}p{5cm}}
\includegraphics[width=5cm]{Images/Multicall_conv.eps} &
\includegraphics[width=5cm]{Images/Multicall_error.eps}\tabularnewline
a) & b)
\end{tabular}
\caption{a) Tolerance against predicted error, b) Price obtained with its tolerance bounds. \label{BasketOption}}
\end{figure}

\section{Discussion and Future Work}
Quasi-Monte Carlo methods rarely provide guaranteed and adaptive algorithms. Developing a new methodology to bound the absolute error allowed us building an adaptive automatic guaranteed algorithm based on cones of functions. The definition of function cone sets is a challenging new viewpoint. The non convexity of the cone leads to non linear algorithms whose complexity bounds may be hard to find. In this article we also provide an upper bound on the complexity, yet the lower bound remains to be specified. In the future, we also want to link this work to other results provided in the literature by fitting this cone set into more common spaces, like the Korobov spaces. Finally, we are also interested in considering the relative error in our algorithm.


\begin{acknowledgement}
The authors thank Ronald Cools and Dirk Nuyens for organizing MCQMC 2014 and greatly appreciate the suggestions made by Sou-Cheng Choi, Frances Kuo, Lan Jiang, Dirk Nuyens and Yizhi Zhang to improve this manuscript. In addition, also thank Art Owen for the traveling expenses funding.
This work was partially supported by US National Science Foundation grants DMS-1115392 and DMS-1357690. 
\end{acknowledgement}

\bibliographystyle{spmpsci.bst}
\bibliography{FJH22,FJHown23,lluisantoni}

\section*{Appendix: Periodizing the Integrands}\label{apendixperiodizing}
For non periodic integrands $f$, one can use transformations $\phi$ to obtain periodic functions $g$ such that:
\begin{equation}\label{transeq}
\int_{\cube} f(\bsx)  \, \dif \bsx=\int_{\cube} g(\bst)  \, \dif \bst
\end{equation}
where
\begin{equation}\label{gdef}
g(t_1,\dots,t_d)=f(\phi(t_1),\dots,\phi(t_d))\phi'(t_1)\cdots\phi'(t_d)
\end{equation}

One example is the Baker's transform $\phi(t)=1-2\abs{t-0.5}$. A simple calculation in one dimension proves the equality \eqref{transeq} and by the Fubini theorem it can be extended to any dimension. Remark that this transform may generate a periodically extended $g$ not differentiable. Therefore, for smoother integrands $f$ we may loose differentiability after applying the transformation. However, really smooth transformations may introduce waviness. In any of both cases, it implies slower Fourier coefficients decay. See section \ref{sumscoeff} for further implications on this article.

Another option is described in \cite[Sec. 2.12]{SloJoe94}. Here, $\phi$ must be an increasing function which maps $[0,1]$ onto $[0,1]$. If $\phi'(0)=\phi'(1)=0$, by \eqref{gdef} function $g$ becomes periodic. The simplest polynomial fulfilling this conditions is $\phi(t)=3t^2-2t^3$. Again, as for the Baker's transform, this may produce a non differentiable $g$. In this case, one solution if $f\in\cc^n$, is finding the polynomial requiring $\phi^{(i)}(0)=\phi^{(i)}(1)=0$ for $i=1,\dots,n+1$. This then implies $g\in\cc^n$.

A part from polynomials, one could also consider the transform proposed by Sidi in \cite{Sid93}: $\phi(t)=t-\sin(2\pi t)/(2\pi)$.

\end{document}